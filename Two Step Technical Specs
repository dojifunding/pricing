TWO STEP CHALLENGE
Technical Implementation Specification
Version 1.0 | November 2024
ğŸ“Š Classic Dual-Phase Evaluation with Maximum Freedom
â€ƒ
1. EXECUTIVE SUMMARY
The Two Step Challenge represents the industry-standard evaluation approach enhanced with unprecedented customization options. This dual-phase system provides comprehensive trader assessment while offering maximum trading freedom and scaling opportunities up to 10Ã— the initial capital.
Core Advantages:
â€¢	Dual-phase evaluation for thorough assessment
â€¢	Complete parameter customization
â€¢	Maximum trading freedom (all strategies allowed)
â€¢	10Ã— scaling potential
â€¢	70-90% profit split
â€¢	Pre-optimized templates available
2. SYSTEM ARCHITECTURE
2.1 Two-Phase Architecture Design
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚                  Two Step Challenge System                      â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚                                                                 â”‚ â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚ â”‚  â”‚     PHASE ONE        â”‚      â”‚     PHASE TWO        â”‚       â”‚ â”‚  â”‚  (Evaluation Phase)  â”‚ â”€â”€â”€â–º â”‚ (Verification Phase) â”‚       â”‚ â”‚  â”‚                      â”‚      â”‚                      â”‚       â”‚ â”‚  â”‚  â€¢ Higher Target     â”‚      â”‚  â€¢ Lower Target      â”‚       â”‚ â”‚  â”‚  â€¢ Risk Assessment   â”‚      â”‚  â€¢ Consistency Check â”‚       â”‚ â”‚  â”‚  â€¢ Strategy Analysis â”‚      â”‚  â€¢ Final Validation  â”‚       â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ â”‚            â”‚                              â”‚                     â”‚ â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚ â”‚                      â–¼                                         â”‚ â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚ â”‚         â”‚   FUNDED ACCOUNT     â”‚                              â”‚ â”‚         â”‚   â€¢ Full Capital     â”‚                              â”‚ â”‚         â”‚   â€¢ 10Ã— Scaling      â”‚                              â”‚ â”‚         â”‚   â€¢ Profit Split     â”‚                              â”‚ â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚ â”‚                                                                 â”‚ â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚ â”‚  â”‚              Supporting Infrastructure               â”‚       â”‚ â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”‚ â”‚  â”‚ â€¢ Phase Transition Service                          â”‚       â”‚ â”‚  â”‚ â€¢ Template Management System                        â”‚       â”‚ â”‚  â”‚ â€¢ Performance Analytics Engine                      â”‚       â”‚ â”‚  â”‚ â€¢ Scaling Calculator Service                        â”‚       â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
2.2 Service Architecture
apiVersion: v1 kind: Architecture metadata:   name: two-step-challenge spec:   services:     - name: phase-manager       type: StatefulService       language: Node.js       responsibilities:         - Phase transition logic         - State management         - Progress tracking         - Completion validation            - name: configuration-service       type: Service       language: Python       responsibilities:         - Parameter validation         - Template management         - Custom configuration         - Pricing calculation            - name: evaluation-engine       type: Service       language: Go       responsibilities:         - Real-time evaluation         - Metric calculation         - Performance analysis         - Risk assessment            - name: scaling-service       type: Service       language: Python       responsibilities:         - Scaling eligibility         - Capital calculation         - Risk adjustment         - Progressive scaling          databases:     - PostgreSQL (primary)     - TimescaleDB (time-series)     - Redis (caching/sessions)     - MongoDB (analytics)
3. DUAL-PHASE CONFIGURATION
3.1 Phase-Specific Parameters
Parameter	Phase 1	Phase 2	Funded
Profit Target	5-12%	3-8%	None
Daily Loss	3-8%	3-8%	3-8%
Max Loss	6-15%	6-15%	6-15%
Min Trading Days	Variable	Variable	None
Consistency Rule	35-50%	35-50%	Flexible
Profit Split	N/A	N/A	70-90%
3.2 Pre-Configured Templates
const twoStepTemplates = {     "aggressive": {         name: "Aggressive Trader",         description: "High risk, high reward configuration",         phase1: {             profitTarget: 10,             dailyLoss: 6,             maxLoss: 12         },         phase2: {             profitTarget: 5,             dailyLoss: 6,             maxLoss: 12         },         totalDays: 10,         consistency: 35,         profitSplit: 80     },     "balanced": {         name: "Balanced Approach",         description: "Standard risk/reward ratio",         phase1: {             profitTarget: 8,             dailyLoss: 5,             maxLoss: 10         },         phase2: {             profitTarget: 5,             dailyLoss: 5,             maxLoss: 10         },         totalDays: 15,         consistency: 45,         profitSplit: 80     },     "conservative": {         name: "Conservative Trader",         description: "Lower risk, steady growth",         phase1: {             profitTarget: 6,             dailyLoss: 3,             maxLoss: 6         },         phase2: {             profitTarget: 3,             dailyLoss: 3,             maxLoss: 6         },         totalDays: 20,         consistency: 50,         profitSplit: 85     } };
4. DYNAMIC PRICING ENGINE
4.1 Advanced Pricing Algorithm
class TwoStepPricingEngine {     constructor() {         this.basePrices = {             5000: 69,             10000: 89,             25000: 149,             50000: 249,             100000: 399,             200000: 699         };     }          calculatePrice(config) {         const basePrice = this.basePrices[config.accountSize];         let difficultyAdjustment = 0;         let splitAdjustment = 0;                  // Combined phase targets         const totalTarget = config.phase1Target + config.phase2Target;                  // Target Difficulty Adjustments         if (totalTarget < 13) {             // Easier targets = higher price             difficultyAdjustment += (13 - totalTarget) * 15;         } else if (totalTarget > 15) {             // Harder targets = lower price             difficultyAdjustment -= (totalTarget - 15) * 10;         }                  // Daily Loss Risk Adjustments         const avgDailyLoss = (config.phase1DailyLoss + config.phase2DailyLoss) / 2;         if (avgDailyLoss > 5) {             // Higher risk = higher price             difficultyAdjustment += (avgDailyLoss - 5) * 50;         } else if (avgDailyLoss < 5) {             // Lower risk = lower price             difficultyAdjustment -= (5 - avgDailyLoss) * 25;         }                  // Max Loss Risk Adjustments         const avgMaxLoss = (config.phase1MaxLoss + config.phase2MaxLoss) / 2;         if (avgMaxLoss > 10) {             // Higher max loss = higher price             difficultyAdjustment += (avgMaxLoss - 10) * 45;         } else if (avgMaxLoss < 10) {             // Lower max loss = lower price             difficultyAdjustment -= (10 - avgMaxLoss) * 20;         }                  // Trading Days Adjustment         if (config.totalDays < 10) {             difficultyAdjustment += (10 - config.totalDays) * 10;         }                  // Consistency Rule Adjustment         if (config.consistency < 45) {             difficultyAdjustment += (45 - config.consistency) * 3;         }                  // Profit Split Adjustment         splitAdjustment = (config.profitSplit - 80) * 6;                  // Template Discount         let templateDiscount = 0;         if (config.useTemplate) {             templateDiscount = basePrice * 0.1; // 10% off for templates         }                  // Calculate final price         const finalPrice = Math.max(             basePrice + difficultyAdjustment + splitAdjustment - templateDiscount,             basePrice * 0.5         );                  return {             basePrice,             difficultyAdjustment,             splitAdjustment,             templateDiscount,             finalPrice: Math.round(finalPrice),             estimatedValue: this.calculateValue(config)         };     }          calculateValue(config) {         // Calculate expected value for trader         const successRate = this.estimateSuccessRate(config);         const avgMonthlyPayout = config.accountSize * 0.05 * (config.profitSplit / 100);         const scalingPotential = config.accountSize * 10; // 10x scaling                  return {             successRate: `${(successRate * 100).toFixed(1)}%`,             avgMonthlyPayout,             maxScaledCapital: scalingPotential,             breakEvenMonths: Math.ceil(config.finalPrice / avgMonthlyPayout),             yearlyPotential: avgMonthlyPayout * 12         };     }          estimateSuccessRate(config) {         // Statistical model based on configuration difficulty         const targetDifficulty = (config.phase1Target + config.phase2Target) / 20;         const riskFactor = ((config.phase1MaxLoss + config.phase2MaxLoss) / 2) / 10;         const timeFactor = Math.min(config.totalDays / 30, 1);                  // Base success rate modified by factors         const baseRate = 0.35; // 35% base success rate         const adjustedRate = baseRate * (1 - targetDifficulty + riskFactor + timeFactor);                  return Math.min(Math.max(adjustedRate, 0.15), 0.65); // 15-65% range     } }
5. DATABASE SCHEMA
5.1 Main Tables
-- Two Step Challenge main table CREATE TABLE two_step_evaluations (     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),     user_id UUID NOT NULL REFERENCES users(id),     account_number VARCHAR(20) UNIQUE NOT NULL,          -- Account Configuration     account_size DECIMAL(10, 2) NOT NULL,     profit_split INTEGER NOT NULL CHECK (profit_split BETWEEN 70 AND 90),     template_used VARCHAR(50),          -- Phase 1 Configuration     phase1_profit_target DECIMAL(3, 1) NOT NULL CHECK (phase1_profit_target BETWEEN 5 AND 12),     phase1_daily_loss DECIMAL(3, 1) NOT NULL CHECK (phase1_daily_loss BETWEEN 3 AND 8),     phase1_max_loss DECIMAL(3, 1) NOT NULL CHECK (phase1_max_loss BETWEEN 6 AND 15),          -- Phase 2 Configuration     phase2_profit_target DECIMAL(3, 1) NOT NULL CHECK (phase2_profit_target BETWEEN 3 AND 8),     phase2_daily_loss DECIMAL(3, 1) NOT NULL CHECK (phase2_daily_loss BETWEEN 3 AND 8),     phase2_max_loss DECIMAL(3, 1) NOT NULL CHECK (phase2_max_loss BETWEEN 6 AND 15),          -- Common Configuration     total_min_days INTEGER NOT NULL CHECK (total_min_days BETWEEN 5 AND 20),     consistency_rule DECIMAL(3, 1) NOT NULL CHECK (consistency_rule BETWEEN 35 AND 50),          -- Current Status     current_phase INTEGER NOT NULL DEFAULT 1 CHECK (current_phase IN (1, 2, 3)),     phase_status VARCHAR(20) NOT NULL DEFAULT 'active',     overall_status VARCHAR(20) NOT NULL DEFAULT 'active',          -- Timestamps     created_at TIMESTAMP NOT NULL DEFAULT NOW(),     phase1_started_at TIMESTAMP,     phase1_completed_at TIMESTAMP,     phase2_started_at TIMESTAMP,     phase2_completed_at TIMESTAMP,     funded_at TIMESTAMP,          -- Pricing     base_price DECIMAL(8, 2) NOT NULL,     difficulty_adjustment DECIMAL(8, 2) NOT NULL,     split_adjustment DECIMAL(8, 2) NOT NULL,     template_discount DECIMAL(8, 2) DEFAULT 0,     final_price DECIMAL(8, 2) NOT NULL,          -- Risk Metrics     risk_score DECIMAL(4, 2),     estimated_success_rate DECIMAL(4, 2),          INDEX idx_user_id (user_id),     INDEX idx_current_phase (current_phase),     INDEX idx_overall_status (overall_status),     INDEX idx_created_at (created_at) );
-- Phase-specific performance tracking CREATE TABLE two_step_phase_performance (     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),     evaluation_id UUID NOT NULL REFERENCES two_step_evaluations(id),     phase INTEGER NOT NULL CHECK (phase IN (1, 2)),          -- Balance Tracking     starting_balance DECIMAL(10, 2) NOT NULL,     current_balance DECIMAL(10, 2) NOT NULL,     peak_balance DECIMAL(10, 2) NOT NULL,     lowest_balance DECIMAL(10, 2) NOT NULL,          -- Target & Limits     profit_target_amount DECIMAL(10, 2) NOT NULL,     daily_loss_limit DECIMAL(10, 2) NOT NULL,     max_loss_limit DECIMAL(10, 2) NOT NULL,          -- Trading Statistics     total_trades INTEGER DEFAULT 0,     winning_trades INTEGER DEFAULT 0,     losing_trades INTEGER DEFAULT 0,     trading_days INTEGER DEFAULT 0,     best_trade DECIMAL(10, 2),     worst_trade DECIMAL(10, 2),     avg_trade DECIMAL(10, 2),          -- Performance Metrics     win_rate DECIMAL(5, 2),     profit_factor DECIMAL(5, 2),     sharpe_ratio DECIMAL(5, 2),     max_drawdown DECIMAL(5, 2),     consistency_score DECIMAL(5, 2),          -- Compliance     has_minimum_trades BOOLEAN DEFAULT FALSE,     meets_consistency BOOLEAN DEFAULT FALSE,     meets_profit_target BOOLEAN DEFAULT FALSE,     no_rule_violations BOOLEAN DEFAULT TRUE,          -- Timestamps     started_at TIMESTAMP NOT NULL DEFAULT NOW(),     completed_at TIMESTAMP,          UNIQUE(evaluation_id, phase),     INDEX idx_evaluation_phase (evaluation_id, phase) );
-- Funded account scaling tracking CREATE TABLE funded_account_scaling (     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),     evaluation_id UUID NOT NULL REFERENCES two_step_evaluations(id),          -- Current Scaling     current_multiplier DECIMAL(3, 1) NOT NULL DEFAULT 1.0,     current_capital DECIMAL(12, 2) NOT NULL,     max_multiplier DECIMAL(3, 1) NOT NULL DEFAULT 10.0,          -- Scaling History     scaling_level INTEGER NOT NULL DEFAULT 1,     last_scaled_at TIMESTAMP,     next_scaling_eligible TIMESTAMP,          -- Performance Requirements     required_profit_months INTEGER NOT NULL DEFAULT 2,     required_consistency DECIMAL(5, 2) NOT NULL DEFAULT 40.0,     required_min_return DECIMAL(5, 2) NOT NULL DEFAULT 10.0,          -- Tracking     consecutive_profit_months INTEGER DEFAULT 0,     total_profit_generated DECIMAL(12, 2) DEFAULT 0,     total_payouts DECIMAL(12, 2) DEFAULT 0,          INDEX idx_evaluation_id (evaluation_id),     INDEX idx_scaling_level (scaling_level) );
6. API ENDPOINTS
6.1 Configuration & Templates
GET /api/two-step/templates  Response: {     "templates": [         {             "id": "aggressive",             "name": "Aggressive Trader",             "description": "High risk, high reward configuration",             "successRate": "28%",             "avgCompletionDays": 12,             "configuration": {                 "phase1": { "profitTarget": 10, "dailyLoss": 6, "maxLoss": 12 },                 "phase2": { "profitTarget": 5, "dailyLoss": 6, "maxLoss": 12 },                 "totalDays": 10,                 "consistency": 35,                 "profitSplit": 80             },             "pricing": {                 "5K": 62,                 "10K": 80,                 "25K": 134,                 "50K": 224,                 "100K": 359             }         },         // ... more templates     ] }
POST /api/two-step/custom-configuration {     "accountSize": 100000,     "phase1": {         "profitTarget": 8,         "dailyLoss": 5,         "maxLoss": 10     },     "phase2": {         "profitTarget": 5,         "dailyLoss": 5,         "maxLoss": 10     },     "totalMinDays": 15,     "consistencyRule": 45,     "profitSplit": 80 }  Response: {     "valid": true,     "configuration": { /* echoed config */ },     "pricing": {         "basePrice": 399,         "difficultyAdjustment": 0,         "splitAdjustment": 0,         "templateDiscount": 0,         "finalPrice": 399     },     "analysis": {         "estimatedSuccessRate": "35.2%",         "avgCompletionDays": 18,         "monthlyPayoutPotential": 4000,         "maxScaledCapital": 1000000,         "breakEvenMonths": 1,         "yearlyPotential": 48000     },     "freedoms": [         "âœ… News trading allowed",         "âœ… Weekend holding allowed",         "âœ… EA/Copy trading allowed",         "âœ… All instruments available",         "âœ… No position size limits"     ] }
6.2 Phase Progression
GET /api/two-step/{evaluationId}/progress  Response: {     "evaluationId": "eval_abc123",     "currentPhase": 1,     "phaseStatus": "active",          "phase1Progress": {         "status": "active",         "currentBalance": 108500,         "profitPercent": 8.5,         "targetPercent": 8,         "progressPercent": 106.25,         "tradingDays": 7,         "canComplete": true,         "violations": []     },          "phase2Progress": {         "status": "pending",         "willUnlock": "Upon Phase 1 completion"     },          "timeline": {         "phase1Started": "2024-11-20T10:00:00Z",         "daysElapsed": 6,         "estimatedCompletion": "2024-11-27T00:00:00Z"     },          "nextActions": [         "Complete remaining trading days (minimum 3 more)",         "Maintain consistency score below 45%",         "Request phase completion validation"     ] }
POST /api/two-step/{evaluationId}/complete-phase  Request: {     "phase": 1,     "confirmMetrics": {         "profitAchieved": 8.5,         "tradingDays": 10,         "consistencyScore": 42.3     } }  Response: {     "success": true,     "phaseCompleted": 1,     "results": {         "finalBalance": 108500,         "totalReturn": 8.5,         "tradingDays": 10,         "totalTrades": 47,         "winRate": 63.8,         "consistency": 42.3     },     "phase2Activated": true,     "phase2Config": {         "startingBalance": 100000,  // Reset to original         "profitTarget": 5,         "dailyLoss": 5,         "maxLoss": 10,         "requiredDays": 5     },     "message": "Congratulations! Phase 1 completed. Phase 2 now active." }
7. PHASE TRANSITION SYSTEM
7.1 Phase Transition Manager
class PhaseTransitionManager {     constructor() {         this.transitionRules = {             phase1to2: {                 requirements: [                     'profitTargetMet',                     'minimumTradingDays',                     'consistencyRuleMet',                     'noMajorViolations'                 ],                 actions: [                     'resetBalance',                     'updateTargets',                     'clearMetrics',                     'notifyTrader'                 ]             },             phase2toFunded: {                 requirements: [                     'profitTargetMet',                     'minimumTradingDays',                     'consistencyRuleMet',                     'noViolations',                     'finalReview'                 ],                 actions: [                     'createFundedAccount',                     'assignCapital',                     'enablePayouts',                     'setupScaling'                 ]             }         };     }          async validatePhaseCompletion(evaluationId, phase) {         const evaluation = await this.getEvaluation(evaluationId);         const performance = await this.getPhasePerformance(evaluationId, phase);                  const validations = {             profitTarget: this.validateProfitTarget(performance, evaluation, phase),             tradingDays: this.validateTradingDays(performance, evaluation),             consistency: this.validateConsistency(performance, evaluation),             violations: this.checkViolations(performance)         };                  const allPassed = Object.values(validations).every(v => v.passed);                  if (!allPassed) {             return {                 eligible: false,                 validations,                 missingRequirements: Object.entries(validations)                     .filter(([_, v]) => !v.passed)                     .map(([k, v]) => v.message)             };         }                  return {             eligible: true,             validations,             nextPhase: phase === 1 ? 2 : 'funded'         };     }          async executeTransition(evaluationId, fromPhase, toPhase) {         const transitionKey = `phase${fromPhase}to${toPhase === 'funded' ? 'Funded' : toPhase}`;         const rules = this.transitionRules[transitionKey];                  // Execute transition actions         for (const action of rules.actions) {             await this.executeAction(action, evaluationId, toPhase);         }                  // Record transition         await this.recordTransition({             evaluationId,             fromPhase,             toPhase,             timestamp: new Date(),             performance: await this.getPhasePerformance(evaluationId, fromPhase)         });                  // Send notifications         await this.notifyTransition(evaluationId, toPhase);                  return {             success: true,             newPhase: toPhase,             message: this.getTransitionMessage(toPhase)         };     }          async executeAction(action, evaluationId, toPhase) {         switch (action) {             case 'resetBalance':                 await this.resetAccountBalance(evaluationId);                 break;                              case 'updateTargets':                 await this.updatePhaseTargets(evaluationId, toPhase);                 break;                              case 'clearMetrics':                 await this.clearPhaseMetrics(evaluationId);                 break;                              case 'createFundedAccount':                 await this.createFundedAccount(evaluationId);                 break;                              case 'assignCapital':                 await this.assignTradingCapital(evaluationId);                 break;                              case 'enablePayouts':                 await this.enablePayoutSystem(evaluationId);                 break;                              case 'setupScaling':                 await this.initializeScaling(evaluationId);                 break;         }     } }
8. SCALING SYSTEM
8.1 Progressive Scaling Implementation
class ScalingEngine {     constructor() {         this.scalingSchedule = [             { month: 1, multiplier: 1.0, requirements: { profit: 10, consistency: 45 } },             { month: 2, multiplier: 1.5, requirements: { profit: 10, consistency: 45 } },             { month: 3, multiplier: 2.0, requirements: { profit: 10, consistency: 40 } },             { month: 4, multiplier: 3.0, requirements: { profit: 10, consistency: 40 } },             { month: 6, multiplier: 5.0, requirements: { profit: 10, consistency: 35 } },             { month: 9, multiplier: 7.5, requirements: { profit: 10, consistency: 35 } },             { month: 12, multiplier: 10.0, requirements: { profit: 10, consistency: 30 } }         ];     }          async evaluateScaling(fundedAccountId) {         const account = await this.getFundedAccount(fundedAccountId);         const performance = await this.getAccountPerformance(fundedAccountId);         const currentLevel = account.scalingLevel;                  // Check if eligible for next level         const nextLevel = this.scalingSchedule[currentLevel];         if (!nextLevel) {             return {                 eligible: false,                 message: 'Maximum scaling reached (10Ã—)',                 currentMultiplier: 10.0             };         }                  // Validate time requirement         const monthsSinceFunding = this.calculateMonths(             account.fundedAt,             new Date()         );                  if (monthsSinceFunding < nextLevel.month) {             return {                 eligible: false,                 message: `Next scaling in ${nextLevel.month - monthsSinceFunding} months`,                 currentMultiplier: account.currentMultiplier,                 nextMultiplier: nextLevel.multiplier,                 requirements: nextLevel.requirements             };         }                  // Validate performance requirements         const meetsRequirements = this.validateRequirements(             performance,             nextLevel.requirements         );                  if (!meetsRequirements.passed) {             return {                 eligible: false,                 message: 'Performance requirements not met',                 currentMultiplier: account.currentMultiplier,                 failedRequirements: meetsRequirements.failures             };         }                  // Eligible for scaling         return {             eligible: true,             currentMultiplier: account.currentMultiplier,             newMultiplier: nextLevel.multiplier,             capitalIncrease: account.baseCapital * (nextLevel.multiplier - account.currentMultiplier),             message: `Eligible for ${nextLevel.multiplier}Ã— scaling`         };     }          async executeScaling(fundedAccountId) {         const eligibility = await this.evaluateScaling(fundedAccountId);                  if (!eligibility.eligible) {             throw new Error(eligibility.message);         }                  const account = await this.getFundedAccount(fundedAccountId);                  // Update account capital         const newCapital = account.baseCapital * eligibility.newMultiplier;                  await this.updateAccount(fundedAccountId, {             currentMultiplier: eligibility.newMultiplier,             currentCapital: newCapital,             scalingLevel: account.scalingLevel + 1,             lastScaledAt: new Date(),             nextScalingEligible: this.calculateNextEligibleDate(account.scalingLevel + 1)         });                  // Update trading limits         await this.updateTradingLimits(fundedAccountId, newCapital);                  // Send notifications         await this.notifyScaling(fundedAccountId, {             oldCapital: account.currentCapital,             newCapital,             multiplier: eligibility.newMultiplier         });                  return {             success: true,             newCapital,             multiplier: eligibility.newMultiplier,             nextMilestone: this.getNextMilestone(account.scalingLevel + 1)         };     }          getNextMilestone(currentLevel) {         const next = this.scalingSchedule[currentLevel + 1];         if (!next) {             return {                 available: false,                 message: 'Maximum scaling reached'             };         }                  return {             available: true,             multiplier: next.multiplier,             monthsRequired: next.month,             requirements: next.requirements         };     } }
9. MAXIMUM TRADING FREEDOM
9.1 Allowed Trading Strategies
Strategy/Feature	Status	Details
News Trading	âœ… Allowed	5min buffer for risky configs
Weekend Holding	âœ… Allowed	All instruments including crypto
EA/Automated Trading	âœ… Allowed	Including HFT with proper risk management
Copy Trading	âœ… Allowed	No verification required
All Instruments	âœ… Allowed	Forex, Indices, Commodities, Crypto, Stocks
Position Limits	None	Unlimited concurrent positions
10. MONITORING & ANALYTICS
10.1 Real-Time Analytics Dashboard
class TwoStepAnalytics {     constructor() {         this.metrics = {             realtime: ['balance', 'equity', 'margin', 'positions'],             calculated: ['drawdown', 'profit', 'consistency', 'risk'],             predictive: ['successProbability', 'estimatedCompletion', 'riskScore']         };     }          async generateDashboard(evaluationId) {         const evaluation = await this.getEvaluation(evaluationId);         const currentPhase = evaluation.currentPhase;                  return {             overview: {                 accountNumber: evaluation.accountNumber,                 currentPhase,                 phaseStatus: evaluation.phaseStatus,                 daysInPhase: this.calculateDaysInPhase(evaluation),                 overallProgress: this.calculateOverallProgress(evaluation)             },                          performance: {                 currentBalance: await this.getCurrentBalance(evaluationId),                 totalReturn: await this.calculateReturn(evaluationId),                 drawdown: await this.calculateDrawdown(evaluationId),                 consistency: await this.calculateConsistency(evaluationId),                 winRate: await this.calculateWinRate(evaluationId)             },                          limits: {                 dailyLoss: {                     limit: evaluation[`phase${currentPhase}_daily_loss`],                     used: await this.getDailyLossUsed(evaluationId),                     remaining: await this.getDailyLossRemaining(evaluationId)                 },                 maxLoss: {                     limit: evaluation[`phase${currentPhase}_max_loss`],                     used: await this.getMaxLossUsed(evaluationId),                     remaining: await this.getMaxLossRemaining(evaluationId)                 },                 profitTarget: {                     target: evaluation[`phase${currentPhase}_profit_target`],                     achieved: await this.getProfitAchieved(evaluationId),                     remaining: await this.getProfitRemaining(evaluationId)                 }             },                          predictions: {                 successProbability: await this.predictSuccess(evaluationId),                 estimatedCompletionDate: await this.estimateCompletion(evaluationId),                 projectedMonthlyPayout: await this.projectPayout(evaluationId),                 scalingTimeline: await this.projectScaling(evaluationId)             },                          recommendations: await this.generateRecommendations(evaluationId)         };     }          async generateRecommendations(evaluationId) {         const performance = await this.getPerformance(evaluationId);         const recommendations = [];                  if (performance.consistency > 45) {             recommendations.push({                 type: 'WARNING',                 message: 'Consistency score approaching limit',                 action: 'Distribute profits more evenly across trading days'             });         }                  if (performance.drawdown > 70) {             recommendations.push({                 type: 'ALERT',                 message: 'High drawdown usage',                 action: 'Reduce position sizes and implement tighter risk management'             });         }                  if (performance.winRate < 40) {             recommendations.push({                 type: 'INFO',                 message: 'Win rate below optimal',                 action: 'Review entry criteria and consider higher probability setups'             });         }                  return recommendations;     } }
11. TESTING STRATEGY
11.1 Comprehensive Test Coverage
describe('Two Step Challenge System', () => {     describe('Phase Transitions', () => {         test('successfully transitions from phase 1 to phase 2', async () => {             const evaluation = await createTestEvaluation();             await completePhase1(evaluation.id);                          const result = await transitionPhase(evaluation.id, 1, 2);                          expect(result.success).toBe(true);             expect(result.newPhase).toBe(2);             expect(evaluation.currentPhase).toBe(2);             expect(evaluation.phase2_started_at).toBeDefined();         });                  test('prevents transition with incomplete requirements', async () => {             const evaluation = await createTestEvaluation();             // Don't complete all requirements                          const result = await transitionPhase(evaluation.id, 1, 2);                          expect(result.success).toBe(false);             expect(result.missingRequirements).toContain('Profit target not met');         });     });          describe('Scaling System', () => {         test('correctly calculates scaling eligibility', async () => {             const account = await createFundedAccount();             await simulateMonths(account.id, 2);             await generateProfit(account.id, 10);                          const eligibility = await evaluateScaling(account.id);                          expect(eligibility.eligible).toBe(true);             expect(eligibility.newMultiplier).toBe(1.5);             expect(eligibility.capitalIncrease).toBe(50000); // For 100K account         });                  test('enforces scaling timeline', async () => {             const account = await createFundedAccount();             // Try to scale immediately                          const eligibility = await evaluateScaling(account.id);                          expect(eligibility.eligible).toBe(false);             expect(eligibility.message).toContain('Next scaling in');         });     });          describe('Pricing Engine', () => {         test('applies template discount correctly', async () => {             const config = {                 accountSize: 100000,                 useTemplate: true,                 templateId: 'balanced'             };                          const pricing = await calculatePrice(config);                          expect(pricing.templateDiscount).toBe(39.9); // 10% of base             expect(pricing.finalPrice).toBeLessThan(pricing.basePrice);         });                  test('calculates custom configuration price', async () => {             const config = {                 accountSize: 50000,                 phase1: { profitTarget: 10, dailyLoss: 6, maxLoss: 12 },                 phase2: { profitTarget: 6, dailyLoss: 6, maxLoss: 12 },                 totalMinDays: 10,                 consistencyRule: 40,                 profitSplit: 85             };                          const pricing = await calculatePrice(config);                          expect(pricing.difficultyAdjustment).toBeGreaterThan(0);             expect(pricing.splitAdjustment).toBe(30); // (85-80)*6         });     }); });
12. PERFORMANCE & SCALABILITY
Metric	Target	Scale
API Response Time	< 150ms	P95
Phase Transition	< 1s	P99
Concurrent Accounts	100,000+	Peak
System Uptime	99.99%	Annual
Data Processing	1M trades/min	Sustained
13. DEPLOYMENT STRATEGY
Production Deployment Checklist:
â€¢	Phase transition logic tested and validated
â€¢	Scaling system implemented and tested
â€¢	Template management system operational
â€¢	Analytics dashboard configured
â€¢	Database migrations complete
â€¢	Load testing passed (100K accounts)
â€¢	Monitoring and alerting configured
â€¢	Disaster recovery plan tested
â€¢	API documentation published
â€¢	Customer support trained
14. CONCLUSION
The Two Step Challenge system represents the pinnacle of prop trading evaluation technology. By combining industry-standard dual-phase assessment with unprecedented customization and scaling opportunities, the system delivers:
â€¢	Comprehensive trader assessment through two phases
â€¢	Complete trading freedom with all strategies allowed
â€¢	10Ã— scaling potential for successful traders
â€¢	Template system for easy onboarding
â€¢	Advanced analytics and predictive modeling
â€¢	Scalable architecture supporting 100,000+ accounts
This implementation provides the perfect balance between trader freedom and firm protection, creating a sustainable and profitable evaluation ecosystem that rewards skill and consistency while managing risk effectively.
END OF DOCUMENT
